syntax = "proto3";

package skiff.registry.v1alpha1;

import "buf/validate/validate.proto";
import "google/protobuf/struct.proto";

option go_package = "github.com/skiff-sh/api/go/skiff/registry/v1alpha1";

message Registry {
  string name = 1 [(buf.validate.field).string.min_len = 1];

  string description = 2;

  repeated Package packages = 3;
}

message Package {
  // The name of the package. This should be unique between all packages within a registry.
  string name = 1 [(buf.validate.field).string.min_len = 1];

  // A short description of the purpose of this package and what it contains. Should be LLM-friendly. Supports markdown.
  string description = 2 [(buf.validate.field).string.min_len = 1];

  repeated File files = 3;

  // If a field does not have a default, it is marked as required.
  optional Schema schema = 4;
}

message Schema {
  option (buf.validate.message).cel = {
    id: "unique_field_names"
    message: "all field names must be unique"
    expression: "this.fields.map(v, v.name).unique()"
  };

  repeated Field fields = 1;
}

message Field {
  // buf:lint:ignore ENUM_VALUE_UPPER_SNAKE_CASE
  // buf:lint:ignore ENUM_VALUE_PREFIX
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
  enum Type {
    string = 0;
    bool = 1;
    number = 2;
    array = 3;
  }

  option (buf.validate.message).cel = {
    message: 'enums only supported for type number, or string'
    id: 'enums_type_invalid'
    expression: 'has(this.enum) ? this.type in [skiff.registry.v1alpha1.Field.Type.string, skiff.registry.v1alpha1.Field.Type.number] : true'
  };

  option (buf.validate.message).cel = {
    message: 'items required for arrays'
    id: 'items_required'
    expression: 'this.type == skiff.registry.v1alpha1.Field.Type.array ? (has(this.items) && has(this.items.type)): true'
  };

  option (buf.validate.message).cel = {
    id: "default_must_be_in_enum"
    message: "default value must be one of enum values when enum is set"
    expression: "has(this.default) && size(this.enum) > 0 ? this.default in this.enum : true"
  };

  message SubField {
    option (buf.validate.message).cel = {
      message: 'enums only supported for type number or string'
      id: 'enums_type_invalid'
      expression: 'has(this.enum) ? this.type in [skiff.registry.v1alpha1.Field.Type.string, skiff.registry.v1alpha1.Field.Type.number] : true'
    };

    // Required. Can be a string or number.
    optional Type type = 1 [
      (buf.validate.field).required = true,
      (buf.validate.field).enum = {
        in: [
          0,
          2
        ]
      }
    ];

    // Restrict your options to a set of values to choose.
    optional google.protobuf.ListValue enum = 2;
  }

  // The name of the field. This must be unique between all fields.
  string name = 1 [(buf.validate.field).string.min_len = 1];

  // The expected type of the field.
  optional Type type = 2 [(buf.validate.field).required = true];

  // If the type is set to "array", this specifies the underlying type. Required if type is "array".
  optional SubField items = 3;

  // A short description of the field. This is highly recommended to provide context to all consumers of your package.
  optional string description = 4;

  // The default value. If set, the field will be marked as optional. If the enum field is set, this field must be one of the enum values.
  optional google.protobuf.Value default = 5;

  // Restrict your options to a set of values to choose.
  optional google.protobuf.ListValue enum = 6;
}

message File {
  // buf:lint:ignore ENUM_VALUE_UPPER_SNAKE_CASE
  // buf:lint:ignore ENUM_VALUE_PREFIX
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
  enum Type {
    file = 0;
    plugin = 1;
  }

  // The source of the contents for this File. This does not need to be populated manually. All fields are mutually exclusive.
  message Source {
    // The raw contents of the file. This field is set if the data is binary.
    optional bytes raw = 1;

    // The text contents of the file. This field will be populated if the file contains valid UTF-8 text.
    optional string text = 2;

    // The index of the file that contains the contents within the same package. This is useful for plugins as the contents
    // can be large. It is better to have a single plugin that can handle multiple files than to have 1 unique plugin per
    // file.
    optional int32 file_index = 3 [json_name = "file_index"];
  }

  // The path to the file relative to the root of the registry. The root of the registry is the directory housing your 'registry.json' file. Cannot be outside of the registry root.
  // If the type is set to "plugin", this path must be to a WASM binary or a Go file (which will be compiled to WASM).
  string path = 1 [(buf.validate.field).string.min_len = 1];

  // The target path of the file relative to the root of the project. Accepts template parameters.
  string target = 2 [(buf.validate.field).string.min_len = 1];

  // The type of the file. Defaults to file.
  Type type = 3;

  // The source for the contents of the file. This does not need to be set manually as it's populated by the "skiff build" command.
  optional Source source = 4;
}
