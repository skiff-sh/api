package main

import (
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// Template for each generated .go file.
var fileTmpl = template.Must(template.New("file").Parse(`// Code generated by protoc-gen-plain-go. DO NOT EDIT.
package {{ .Package }}

{{ range .Messages }}
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .GoName }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{- end }}
}
{{ end }}
`))

type fieldInfo struct {
	GoName   string
	GoType   string
	JSONName string
}

type msgInfo struct {
	Name   string
	Fields []fieldInfo
}

type fileInfo struct {
	Package  string
	Messages []msgInfo
}

func main() {
	err := generate(os.Stdin, os.Stdout)
	if err != nil {
		log.Fatal(err)
	}
}

func generate(reader io.Reader, writer io.Writer) error {
	req, err := parseRequest(reader)
	if err != nil {
		return err
	}

	resp, err := handleRequest(req)
	if err != nil {
		return err
	}

	b, err := proto.Marshal(resp)
	if err != nil {
		return err
	}

	_, err = writer.Write(b)
	if err != nil {
		return err
	}

	return nil
}

func buildFileInfo(fd *descriptorpb.FileDescriptorProto) fileInfo {
	pkg := fd.GetPackage()
	if pkg == "" {
		pkg = "main"
	}
	// Simple mapping: last segment of proto package -> Go package.
	parts := strings.Split(pkg, ".")
	goPkg := parts[len(parts)-1]

	fi := fileInfo{
		Package:  goPkg,
		Messages: nil,
	}

	// Walk all top-level messages (and their nested messages) recursively.
	for _, m := range fd.MessageType {
		walkMessage(fd, m, "", &fi)
	}

	return fi
}

func parseRequest(reader io.Reader) (*pluginpb.CodeGeneratorRequest, error) {
	// Read CodeGeneratorRequest from stdin.
	in, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}

	req := new(pluginpb.CodeGeneratorRequest)
	err = proto.Unmarshal(in, req)
	if err != nil {
		return nil, err
	}
	name := path.Base(req.FileToGenerate[0])
	name = name[:len(path.Ext(name))]

	return req, nil
}

func handleRequest(req *pluginpb.CodeGeneratorRequest) (*pluginpb.CodeGeneratorResponse, error) {
	// Build map: filename -> descriptor, because FileToGenerate gives you filenames.
	filesByName := make(map[string]*descriptorpb.FileDescriptorProto, len(req.ProtoFile))
	for _, fd := range req.ProtoFile {
		filesByName[fd.GetName()] = fd
	}

	resp := new(pluginpb.CodeGeneratorResponse)

	// Only generate for the files protoc / buf explicitly asked us to.
	for _, name := range req.FileToGenerate {
		fd := filesByName[name]
		if fd == nil {
			// Shouldn't happen, but guard anyway.
			continue
		}

		info := buildFileInfo(fd)

		var sb strings.Builder
		if err := fileTmpl.Execute(&sb, info); err != nil {
			return nil, err
		}

		// Derive output filename: foo/bar/baz.proto -> foo/bar/baz.plain.go
		base := strings.TrimSuffix(fd.GetName(), filepath.Ext(fd.GetName()))
		outName := base + ".plain.go"

		resp.File = append(resp.File, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(outName),
			Content: proto.String(sb.String()),
		})
	}

	// Advertise proto3 optional support so buf/protoc stop warning.
	resp.SupportedFeatures = proto.Uint64(
		uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL),
	)

	return resp, nil
}

// walkMessage flattens nested messages by emitting a type per message.
// Nested messages get a prefixed name, e.g. Outer_Inner.
func walkMessage(
	fd *descriptorpb.FileDescriptorProto,
	m *descriptorpb.DescriptorProto,
	prefix string,
	fi *fileInfo,
) {
	name := m.GetName()
	goName := toExported(prefix + name)

	mi := msgInfo{
		Name:   goName,
		Fields: nil,
	}
	for _, f := range m.Field {
		mi.Fields = append(mi.Fields, fieldInfo{
			GoName:   toExported(f.GetName()),
			GoType:   goTypeForField(fd, f, prefix),
			JSONName: f.GetJsonName(),
		})
	}
	fi.Messages = append(fi.Messages, mi)

	// Recurse into nested messages with updated prefix.
	newPrefix := prefix + name + "_"
	for _, nested := range m.NestedType {
		// Skip synthetic entry messages for map fields (if present).
		if nested.GetOptions().GetMapEntry() {
			continue
		}
		walkMessage(fd, nested, newPrefix, fi)
	}
}

func toExported(name string) string {
	if name == "" {
		return ""
	}

	// Normalize separators
	seps := func(r rune) bool {
		return r == '_' || r == '-'
	}

	parts := strings.FieldsFunc(name, seps)
	if len(parts) == 0 {
		return ""
	}

	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}

	return strings.Join(parts, "")
}

func goTypeForField(
	fd *descriptorpb.FileDescriptorProto,
	f *descriptorpb.FieldDescriptorProto,
	prefix string,
) string {
	var base string

	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		base = "string"
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32:
		base = "int32"
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		base = "int64"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32:
		base = "uint32"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64:
		base = "uint64"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		base = "bool"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		base = "[]byte"
	case descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		base = "float32"
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		base = "float64"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		base = "*" + goMessageNameFromTypeName(fd, f.GetTypeName(), prefix)
	default:
		// For enums or anything else you haven't handled yet.
		base = "interface{}"
	}

	// Handle repeated: repeated T -> []T (or []*Msg for messages).
	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		// For message fields, base already starts with "*"
		// so: "*MyMsg" -> "[]*MyMsg"
		if strings.HasPrefix(base, "*") {
			return "[]" + base
		}
		return "[]" + base
	}

	// Handle proto3 optional: map to pointer type for primitives.
	// (Messages are already pointers, so we leave those alone.)
	if f.GetProto3Optional() {
		if strings.HasPrefix(base, "*") {
			// already pointer (message type)
			return base
		}
		return "*" + base
	}

	return base
}

// goMessageNameFromTypeName maps a protobuf type name (".pkg.Outer.Inner")
// to the generated Go struct name ("Outer_Inner" with current prefix handling).
func goMessageNameFromTypeName(
	fd *descriptorpb.FileDescriptorProto,
	typeName string,
	prefix string,
) string {
	// typeName is usually like ".my.api.v1.Outer.Inner"
	// We just care about the message path segments after the package.
	if !strings.HasPrefix(typeName, ".") {
		return toExported(typeName) // fallback
	}
	typeName = typeName[1:] // strip leading '.'

	pkg := fd.GetPackage()
	var msgPath string
	if pkg != "" && strings.HasPrefix(typeName, pkg+".") {
		msgPath = strings.TrimPrefix(typeName, pkg+".")
	} else {
		msgPath = typeName
	}

	segments := strings.Split(msgPath, ".") // ["Outer", "Inner"]
	for i, s := range segments {
		segments[i] = toExported(s)
	}
	// Our walkMessage uses "Outer_Inner" naming for nested.
	return strings.Join(segments, "_")
}
