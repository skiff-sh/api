package main

import (
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// Template for each generated .go file.
var fileTmpl = template.Must(template.New("file").Parse(`// Code generated by protoc-gen-plain-go. DO NOT EDIT.
package {{ .Package }}

{{ range .Messages }}
{{- if .Comment }}
{{ .Comment }}
{{- end }}
type {{ .Name }} struct {
{{- range .Fields }}
	{{- if .Comment }}
	{{ .Comment }}
	{{- end }}
	{{ .GoName }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{- end }}
}
{{ end }}
`))

type fieldInfo struct {
	GoName   string
	GoType   string
	JSONName string
	Comment  string
}

type msgInfo struct {
	Name    string
	Fields  []fieldInfo
	Comment string
}

type fileInfo struct {
	Package  string
	Messages []msgInfo
}

func main() {
	if err := generate(os.Stdin, os.Stdout); err != nil {
		log.Fatal(err)
	}
}

func generate(reader io.Reader, writer io.Writer) error {
	req, err := parseRequest(reader)
	if err != nil {
		return err
	}

	resp, err := handleRequest(req)
	if err != nil {
		return err
	}

	b, err := proto.Marshal(resp)
	if err != nil {
		return err
	}

	_, err = writer.Write(b)
	return err
}

func parseRequest(reader io.Reader) (*pluginpb.CodeGeneratorRequest, error) {
	in, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}

	req := new(pluginpb.CodeGeneratorRequest)
	if err := proto.Unmarshal(in, req); err != nil {
		return nil, err
	}

	// Not used currently, but kept if you want to derive names later.
	_ = path.Base(req.FileToGenerate[0])

	return req, nil
}

func handleRequest(req *pluginpb.CodeGeneratorRequest) (*pluginpb.CodeGeneratorResponse, error) {
	// Build map: filename -> descriptor, because FileToGenerate gives you filenames.
	filesByName := make(map[string]*descriptorpb.FileDescriptorProto, len(req.ProtoFile))
	for _, fd := range req.ProtoFile {
		filesByName[fd.GetName()] = fd
	}

	resp := new(pluginpb.CodeGeneratorResponse)

	// Only generate for the files protoc / buf explicitly asked us to.
	for _, name := range req.FileToGenerate {
		fd := filesByName[name]
		if fd == nil {
			continue
		}

		info := buildFileInfo(fd)

		var sb strings.Builder
		if err := fileTmpl.Execute(&sb, info); err != nil {
			return nil, err
		}

		// Derive output filename: foo/bar/baz.proto -> foo/bar/baz.plain.go
		base := strings.TrimSuffix(fd.GetName(), filepath.Ext(fd.GetName()))
		outName := base + ".plain.go"

		resp.File = append(resp.File, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(outName),
			Content: proto.String(sb.String()),
		})
	}

	// Advertise proto3 optional support so buf/protoc stop warning.
	resp.SupportedFeatures = proto.Uint64(
		uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL),
	)

	return resp, nil
}

func buildFileInfo(fd *descriptorpb.FileDescriptorProto) fileInfo {
	pkg := fd.GetPackage()
	if pkg == "" {
		pkg = "main"
	}
	// Simple mapping: last segment of proto package -> Go package.
	parts := strings.Split(pkg, ".")
	goPkg := parts[len(parts)-1]

	comments := buildCommentMap(fd)

	fi := fileInfo{
		Package:  goPkg,
		Messages: nil,
	}

	// Walk all top-level messages (and their nested messages) recursively.
	for i, m := range fd.MessageType {
		// Descriptor path for top-level message: [4, i]
		walkMessage(fd, m, "", []int32{4, int32(i)}, comments, &fi)
	}

	return fi
}

// buildCommentMap collects leading comments for all descriptor paths in a file.
// Key is a stringified path (e.g. "4,0,2,1"), value is a ready-to-print block:
//
//	// line1
//	// line2
func buildCommentMap(fd *descriptorpb.FileDescriptorProto) map[string]string {
	m := make(map[string]string)
	if fd.SourceCodeInfo == nil {
		return m
	}
	for _, loc := range fd.SourceCodeInfo.Location {
		if loc.LeadingComments == nil {
			continue
		}
		raw := loc.GetLeadingComments()
		raw = strings.TrimRight(raw, "\n")
		if strings.TrimSpace(raw) == "" {
			continue
		}
		lines := strings.Split(raw, "\n")
		var b strings.Builder
		for i, line := range lines {
			b.WriteString("// ")
			b.WriteString(strings.TrimRight(line, " "))
			if i < len(lines)-1 {
				b.WriteByte('\n')
			}
		}
		m[pathKey(loc.Path)] = b.String()
	}
	return m
}

func pathKey(path []int32) string {
	if len(path) == 0 {
		return ""
	}
	var b strings.Builder
	for i, p := range path {
		if i > 0 {
			b.WriteByte(',')
		}
		b.WriteString(strconvI32(p))
	}
	return b.String()
}

func strconvI32(v int32) string {
	return strconvI(int(v))
}

func strconvI(v int) string {
	// tiny, allocation-free-ish int â†’ string helper
	return strconv.Itoa(v)
}

// walkMessage flattens nested messages by emitting a type per message.
// Nested messages get a prefixed name, e.g. Outer_Inner.
// msgPath is the descriptor path for this message (e.g. [4,0] or [4,0,3,1]).
func walkMessage(
	fd *descriptorpb.FileDescriptorProto,
	m *descriptorpb.DescriptorProto,
	prefix string,
	msgPath []int32,
	comments map[string]string,
	fi *fileInfo,
) {
	name := m.GetName()
	goName := toExported(prefix + name)

	msgComment := comments[pathKey(msgPath)]

	mi := msgInfo{
		Name:    goName,
		Fields:  nil,
		Comment: msgComment,
	}

	// Fields: relative path [2, fieldIndex] under this message.
	for i, f := range m.Field {
		fieldPath := append(append([]int32{}, msgPath...), 2, int32(i))
		fieldComment := comments[pathKey(fieldPath)]

		mi.Fields = append(mi.Fields, fieldInfo{
			GoName:   toExported(f.GetName()),
			GoType:   goTypeForField(fd, f, prefix),
			JSONName: f.GetJsonName(),
			Comment:  fieldComment,
		})
	}
	fi.Messages = append(fi.Messages, mi)

	// Recurse into nested messages with updated prefix and path.
	// Nested descriptor path: parentPath + [3, nestedIndex]
	for i, nested := range m.NestedType {
		// Skip synthetic entry messages for map fields (we treat those via the map logic).
		if nested.GetOptions().GetMapEntry() {
			continue
		}
		nestedPath := append(append([]int32{}, msgPath...), 3, int32(i))
		walkMessage(fd, nested, prefix+name+"_", nestedPath, comments, fi)
	}
}

func toExported(name string) string {
	if name == "" {
		return ""
	}

	// Normalize separators: support snake_case and kebab-case.
	seps := func(r rune) bool {
		return r == '_' || r == '-'
	}

	parts := strings.FieldsFunc(name, seps)
	if len(parts) == 0 {
		return ""
	}

	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}

	return strings.Join(parts, "")
}

// findMessageByFullName finds a message by its fully-qualified name
// (without leading '.'), e.g. "my.pkg.Outer.Inner".
func findMessageByFullName(
	fd *descriptorpb.FileDescriptorProto,
	fullName string,
) *descriptorpb.DescriptorProto {
	pkg := fd.GetPackage()

	var res *descriptorpb.DescriptorProto
	var walk func(msgs []*descriptorpb.DescriptorProto, prefix string)

	walk = func(msgs []*descriptorpb.DescriptorProto, prefix string) {
		for _, m := range msgs {
			name := m.GetName()
			curr := name
			if prefix != "" {
				curr = prefix + "." + name
			}
			fq := curr
			if pkg != "" {
				fq = pkg + "." + curr
			}
			if fq == fullName {
				res = m
				return
			}
			walk(m.NestedType, curr)
			if res != nil {
				return
			}
		}
	}

	walk(fd.MessageType, "")
	return res
}

// if f is a map field, return its synthetic map-entry message descriptor.
// Otherwise returns nil.
func findMapEntryMessage(
	fd *descriptorpb.FileDescriptorProto,
	f *descriptorpb.FieldDescriptorProto,
) *descriptorpb.DescriptorProto {
	if f.GetType() != descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		return nil
	}
	typeName := strings.TrimPrefix(f.GetTypeName(), ".")
	m := findMessageByFullName(fd, typeName)
	if m == nil {
		return nil
	}
	if m.GetOptions().GetMapEntry() {
		return m
	}
	return nil
}

func goTypeForMapKey(f *descriptorpb.FieldDescriptorProto) string {
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32:
		return "int32"
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		return "int64"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32:
		return "uint32"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64:
		return "uint64"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "bool"
	default:
		// Protobuf doesn't actually allow most of these as map keys,
		// but we fall back to interface{} instead of failing.
		return "interface{}"
	}
}

func goTypeForMapValue(
	fd *descriptorpb.FileDescriptorProto,
	f *descriptorpb.FieldDescriptorProto,
	prefix string,
) string {
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32:
		return "int32"
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		return "int64"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32:
		return "uint32"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64:
		return "uint64"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "bool"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "[]byte"
	case descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		return "float32"
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		return "float64"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		return "*" + goMessageNameFromTypeName(fd, f.GetTypeName(), prefix)
	default:
		return "interface{}"
	}
}

func goTypeForField(
	fd *descriptorpb.FileDescriptorProto,
	f *descriptorpb.FieldDescriptorProto,
	prefix string,
) string {
	// First, special-case map fields.
	// In descriptors, map fields are:
	//   label = LABEL_REPEATED
	//   type  = TYPE_MESSAGE
	//   type_name -> synthetic entry message with map_entry = true
	if entry := findMapEntryMessage(fd, f); entry != nil {
		var keyField, valueField *descriptorpb.FieldDescriptorProto
		for _, ef := range entry.Field {
			switch ef.GetName() {
			case "key":
				keyField = ef
			case "value":
				valueField = ef
			}
		}
		// Shouldn't happen in valid protos, but guard anyway.
		if keyField == nil || valueField == nil {
			return "map[interface{}]interface{}"
		}
		keyType := goTypeForMapKey(keyField)
		valType := goTypeForMapValue(fd, valueField, prefix)
		return "map[" + keyType + "]" + valType
	}

	// Non-map field: determine base type.
	var base string

	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		base = "string"
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32:
		base = "int32"
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		base = "int64"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32:
		base = "uint32"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64:
		base = "uint64"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		base = "bool"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		base = "[]byte"
	case descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		base = "float32"
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		base = "float64"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		base = "*" + goMessageNameFromTypeName(fd, f.GetTypeName(), prefix)
	default:
		// For enums or anything else you haven't handled yet.
		base = "interface{}"
	}

	// Handle repeated: repeated T -> []T (or []*Msg for messages).
	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		if strings.HasPrefix(base, "*") {
			return "[]" + base
		}
		return "[]" + base
	}

	// Handle proto3 optional: map to pointer type for primitives.
	// (Messages are already pointers, so we leave those alone.)
	if f.GetProto3Optional() {
		if strings.HasPrefix(base, "*") {
			return base
		}
		return "*" + base
	}

	// Handle oneof: also treat as pointer to allow presence checking.
	if f.OneofIndex != nil {
		if strings.HasPrefix(base, "*") {
			return base
		}
		return "*" + base
	}

	return base
}

// goMessageNameFromTypeName maps a protobuf type name (".pkg.Outer.Inner")
// to the generated Go struct name ("Outer_Inner" with current prefix handling).
func goMessageNameFromTypeName(
	fd *descriptorpb.FileDescriptorProto,
	typeName string,
	prefix string,
) string {
	// typeName is usually like ".my.api.v1.Outer.Inner"
	// We just care about the message path segments after the package.
	if !strings.HasPrefix(typeName, ".") {
		return toExported(typeName) // fallback
	}
	typeName = typeName[1:] // strip leading '.'

	pkg := fd.GetPackage()
	var msgPath string
	if pkg != "" && strings.HasPrefix(typeName, pkg+".") {
		msgPath = strings.TrimPrefix(typeName, pkg+".")
	} else {
		msgPath = typeName
	}

	segments := strings.Split(msgPath, ".") // ["Outer", "Inner"]
	for i, s := range segments {
		segments[i] = toExported(s)
	}
	// Our walkMessage uses "Outer_Inner" naming for nested.
	return strings.Join(segments, "")
}
